{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.generateCumulativeFunc = exports.OP_CUMMIN = exports.OP_CUMMAX = exports.OP_CUMMUL = exports.OP_CUMSUM = exports.round10 = exports.parseIndex = exports.intersectingColumns = exports.nonMergeColumns = exports.sum = undefined;\nvar _regenerator = require('babel-runtime/regenerator');\nvar _regenerator2 = _interopRequireDefault(_regenerator);\nexports.enumerate = enumerate;\nvar _immutable = require('immutable');\nvar _immutable2 = _interopRequireDefault(_immutable);\nvar _exceptions = require('./exceptions');\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nvar _marked = [enumerate].map(_regenerator2.default.mark);\nvar sum = exports.sum = function sum(iterable) {\n  return iterable.reduce(function (s, v) {\n    return s + v;\n  }, 0);\n};\nfunction enumerate(iterable) {\n  var i, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, x;\n  return _regenerator2.default.wrap(function enumerate$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          i = 0;\n          _iteratorNormalCompletion = true;\n          _didIteratorError = false;\n          _iteratorError = undefined;\n          _context.prev = 4;\n          _iterator = iterable[Symbol.iterator]();\n        case 6:\n          if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {\n            _context.next = 14;\n            break;\n          }\n          x = _step.value;\n          _context.next = 10;\n          return [x, i];\n        case 10:\n          i += 1;\n        case 11:\n          _iteratorNormalCompletion = true;\n          _context.next = 6;\n          break;\n        case 14:\n          _context.next = 20;\n          break;\n        case 16:\n          _context.prev = 16;\n          _context.t0 = _context['catch'](4);\n          _didIteratorError = true;\n          _iteratorError = _context.t0;\n        case 20:\n          _context.prev = 20;\n          _context.prev = 21;\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        case 23:\n          _context.prev = 23;\n          if (!_didIteratorError) {\n            _context.next = 26;\n            break;\n          }\n          throw _iteratorError;\n        case 26:\n          return _context.finish(23);\n        case 27:\n          return _context.finish(20);\n        case 28:\n        case 'end':\n          return _context.stop();\n      }\n    }\n  }, _marked[0], this, [[4, 16, 20, 28], [21,, 23, 27]]);\n}\nvar nonMergeColumns = exports.nonMergeColumns = function nonMergeColumns(columns, on) {\n  return columns.filter(function (k) {\n    return on.indexOf(k) < 0;\n  });\n};\nvar intersectingColumns = exports.intersectingColumns = function intersectingColumns(cols1, cols2) {\n  return cols1.filter(function (k) {\n    return cols2.indexOf(k) >= 0;\n  });\n};\nvar parseIndex = exports.parseIndex = function parseIndex(index, values) {\n  if (Array.isArray(index)) {\n    if (values.size !== index.length) throw new _exceptions.IndexMismatchError('values size not equal to index size');\n    return _immutable2.default.List(index);\n  } else if (index instanceof _immutable2.default.List) {\n    if (values.size !== index.size) throw new _exceptions.IndexMismatchError('values size not equal to index size');\n    return index;\n  } else if (typeof index !== 'undefined') {\n    if (values.size !== 1) throw new _exceptions.IndexMismatchError();\n    return _immutable2.default.List([index]);\n  } else if (typeof index === 'undefined') {\n    return _immutable2.default.Range(0, values.size).toList();\n  } else {\n    throw new _exceptions.IndexMismatchError();\n  }\n};\nvar decimalAdjust = function decimalAdjust(type, value, exp) {\n  if (typeof exp === 'undefined' || +exp === 0) {\n    return Math[type](value);\n  }\n  value = +value;\n  exp = +exp;\n  if (isNaN(value) || !(typeof exp === 'number' && exp % 1 === 0)) {\n    return NaN;\n  }\n  value = value.toString().split('e');\n  value = Math[type](+(value[0] + 'e' + (value[1] ? +value[1] - exp : -exp)));\n  value = value.toString().split('e');\n  return +(value[0] + 'e' + (value[1] ? +value[1] + exp : exp));\n};\nvar round10 = exports.round10 = function round10(value, exp) {\n  return decimalAdjust('round', value, exp);\n};\nvar OP_CUMSUM = exports.OP_CUMSUM = 'OP_CUMSUM';\nvar OP_CUMMUL = exports.OP_CUMMUL = 'OP_CUMMUL';\nvar OP_CUMMAX = exports.OP_CUMMAX = 'OP_CUMMAX';\nvar OP_CUMMIN = exports.OP_CUMMIN = 'OP_CUMMIN';\nvar generateCumulativeFunc = exports.generateCumulativeFunc = function generateCumulativeFunc(operation) {\n  switch (operation) {\n    case OP_CUMSUM:\n      return function (values) {\n        var agg = 0;\n        return values.map(function (v) {\n          agg += v;\n          return agg;\n        });\n      };\n    case OP_CUMMUL:\n      return function (values) {\n        var agg = 1;\n        return values.map(function (v) {\n          agg *= v;\n          return agg;\n        });\n      };\n    case OP_CUMMAX:\n      return function (values) {\n        var maxVal = Number.NEGATIVE_INFINITY;\n        return values.map(function (v) {\n          maxVal = Math.max(maxVal, v);\n          return maxVal;\n        });\n      };\n    case OP_CUMMIN:\n      return function (values) {\n        var minVal = Number.POSITIVE_INFINITY;\n        return values.map(function (v) {\n          minVal = Math.min(minVal, v);\n          return minVal;\n        });\n      };\n    default:\n      throw new Error('Not implemented for ' + operation);\n  }\n};","map":null,"metadata":{},"sourceType":"script"}