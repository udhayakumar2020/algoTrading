{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports._concatDataFrame = exports.mergeDataFrame = undefined;\nvar _toConsumableArray2 = require('babel-runtime/helpers/toConsumableArray');\nvar _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);\nvar _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');\nvar _slicedToArray3 = _interopRequireDefault(_slicedToArray2);\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\nvar _createClass2 = require('babel-runtime/helpers/createClass');\nvar _createClass3 = _interopRequireDefault(_createClass2);\nvar _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\nvar _get2 = require('babel-runtime/helpers/get');\nvar _get3 = _interopRequireDefault(_get2);\nvar _inherits2 = require('babel-runtime/helpers/inherits');\nvar _inherits3 = _interopRequireDefault(_inherits2);\nvar _typeof2 = require('babel-runtime/helpers/typeof');\nvar _typeof3 = _interopRequireDefault(_typeof2);\nvar _immutable = require('immutable');\nvar _immutable2 = _interopRequireDefault(_immutable);\nvar _exceptions = require('./exceptions');\nvar _generic = require('./generic');\nvar _generic2 = _interopRequireDefault(_generic);\nvar _series = require('./series');\nvar _series2 = _interopRequireDefault(_series);\nvar _utils = require('./utils');\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nvar parseArrayToSeriesMap = function parseArrayToSeriesMap(array, index) {\n  var dataMap = _immutable2.default.Map({});\n  array.forEach(function (el) {\n    if (el instanceof _immutable2.default.Map) {\n      el.keySeq().forEach(function (k) {\n        if (dataMap.has(k)) {\n          dataMap = dataMap.set(k, dataMap.get(k).push(el.get(k)));\n        } else {\n          dataMap = dataMap.set(k, _immutable2.default.List.of(el.get(k)));\n        }\n      });\n    } else if ((typeof el === 'undefined' ? 'undefined' : (0, _typeof3.default)(el)) === 'object') {\n      Object.keys(el).forEach(function (k) {\n        if (dataMap.has(k)) {\n          dataMap = dataMap.set(k, dataMap.get(k).push(el[k]));\n        } else {\n          dataMap = dataMap.set(k, _immutable2.default.List.of(el[k]));\n        }\n      });\n    }\n  });\n  dataMap.keySeq().forEach(function (k) {\n    dataMap = dataMap.set(k, new _series2.default(dataMap.get(k), {\n      name: k,\n      index: index\n    }));\n  });\n  return _immutable2.default.Map(dataMap);\n};\nvar DataFrame = function (_NDFrame) {\n  (0, _inherits3.default)(DataFrame, _NDFrame);\n  function DataFrame(data) {\n    var kwargs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    (0, _classCallCheck3.default)(this, DataFrame);\n    var _this = (0, _possibleConstructorReturn3.default)(this, (DataFrame.__proto__ || Object.getPrototypeOf(DataFrame)).call(this, data, kwargs));\n    if (Array.isArray(data)) {\n      _this.set_axis(0, (0, _utils.parseIndex)(kwargs.index, _immutable2.default.List(data)));\n      _this._data = parseArrayToSeriesMap(data, _this.index);\n      _this.set_axis(1, _this._data.keySeq());\n    } else if (data instanceof _immutable2.default.Map) {\n      _this._data = _immutable2.default.OrderedMap(data.keySeq().map(function (k) {\n        if (data instanceof _immutable2.default.Map && !(data.get(k) instanceof _series2.default)) throw new Error('Map must have [column, series] key-value pairs');\n        if (data instanceof _immutable2.default.Map) return [k, data.get(k).copy()];\n        throw new Error('Data is not Map');\n      }));\n      _this.set_axis(1, _this._data.keySeq());\n      _this.set_axis(0, _this._data.get(_this.columns.get(0)).index);\n    } else if (data instanceof _immutable2.default.List) {\n      var columns = void 0;\n      if (Array.isArray(kwargs.columns) || kwargs.columns instanceof _immutable2.default.Seq) columns = _immutable2.default.List(kwargs.columns);else if (kwargs.columns instanceof _immutable2.default.List) columns = kwargs.columns;else if (typeof kwargs.columns === 'undefined') columns = _immutable2.default.Range(0, data.get(0).size).toList();else throw new Error('Invalid columns');\n      _this._values = data;\n      _this._data = _immutable2.default.OrderedMap(columns.map(function (c, colIdx) {\n        return [c, new _series2.default(data.map(function (row) {\n          return row.get(colIdx);\n        }), {\n          index: kwargs.index\n        })];\n      }));\n      _this.set_axis(1, _this._data.keySeq());\n      _this.set_axis(0, _this._data.get(_this.columns.get(0)).index);\n    } else if (typeof data === 'undefined') {\n      _this._data = _immutable2.default.Map({});\n      _this.set_axis(0, _immutable2.default.List.of());\n      _this.set_axis(1, _immutable2.default.Seq.of());\n    }\n    _this._setup_axes(_immutable2.default.List.of(0, 1));\n    return _this;\n  }\n  (0, _createClass3.default)(DataFrame, [{\n    key: 'toString',\n    value: function toString() {\n      var _this2 = this;\n      var string = '\\t|';\n      this.columns.forEach(function (k) {\n        string += '  ' + k + '  |';\n      });\n      var headerRow = '-'.repeat(string.length);\n      string += '\\n' + headerRow + '\\n';\n      var stringUpdate = function stringUpdate(idx) {\n        var s = '';\n        _this2.columns.forEach(function (k) {\n          s += '  ' + _this2._data.get(k).iloc(idx) + '  |';\n        });\n        return s;\n      };\n      for (var idx = 0; idx < this.length; idx += 1) {\n        string += this.index.get(idx) + '\\t|';\n        string += stringUpdate(idx);\n        string += '\\n';\n      }\n      return string;\n    }\n  }, {\n    key: 'copy',\n    value: function copy() {\n      return new DataFrame(this._data, {\n        index: this.index\n      });\n    }\n  }, {\n    key: Symbol.iterator,\n    value: function value() {\n      var _this3 = this;\n      var index = -1;\n      return {\n        next: function next() {\n          index += 1;\n          var done = !(index >= 0 && index < _this3.length);\n          var value = done ? undefined : _immutable2.default.Map(_this3.columns.map(function (k, idx) {\n            return [k, _this3.values.get(index).get(idx)];\n          }));\n          return {\n            value: value,\n            done: done\n          };\n        }\n      };\n    }\n  }, {\n    key: 'iterrows',\n    value: function iterrows() {\n      return (0, _utils.enumerate)(this);\n    }\n  }, {\n    key: 'set',\n    value: function set(column, series) {\n      if (series instanceof _series2.default) return new DataFrame(this._data.set(column, series), this.kwargs);else if (series instanceof _immutable2.default.List || Array.isArray(series)) return new DataFrame(this._data.set(column, new _series2.default(series, {\n        index: this.index,\n        name: column\n      })), this.kwargs);\n      throw new TypeError('series must be a Series!');\n    }\n  }, {\n    key: 'reset_index',\n    value: function reset_index() {\n      var _this4 = this;\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n        drop: false\n      };\n      if (typeof args.drop !== 'undefined' && typeof args.drop !== 'boolean') throw new TypeError('drop must be a boolean');\n      var drop = typeof args.drop === 'undefined' ? false : args.drop;\n      var indexName = 'index';\n      if (this.columnExists('index')) {\n        var i = 0;\n        while (this.columnExists('level_' + i)) {\n          i += 1;\n        }\n        indexName = 'level_' + i;\n      }\n      var data = _immutable2.default.Map(this.columns.map(function (c) {\n        return [c, new _series2.default(_this4.get(c).values)];\n      }));\n      if (!args.drop) data = data.set(indexName, new _series2.default(this.index));\n      return new DataFrame(data);\n    }\n  }, {\n    key: 'iloc',\n    value: function iloc(rowIdx, colIdx) {\n      var _this5 = this;\n      if (typeof rowIdx === 'number') {\n        if (typeof colIdx === 'number') {\n          if (colIdx < 0 || colIdx >= this.shape[1]) throw new Error('colIdx out of bounds');\n          var getCol = this.columns.get(colIdx);\n          return new DataFrame(_immutable2.default.Map([[getCol, this.get(getCol).iloc(rowIdx, rowIdx + 1)]]), {\n            index: this.index.slice(rowIdx, rowIdx + 1)\n          });\n        } else if (Array.isArray(colIdx)) {\n          if (colIdx.length !== 2) throw new Error('colIdx must be length 2 (start and end positions)');\n          if (colIdx[1] <= colIdx[0]) throw new Error('colIdx end position cannot be less than or equal tostart position');\n          if (colIdx[0] < 0 || colIdx[1] > this.shape[1]) throw new Error('colIdx position out of bounds');\n          return new DataFrame(_immutable2.default.Map(_immutable2.default.Range(colIdx[0], colIdx[1]).map(function (idx) {\n            var getCol = _this5.columns.get(idx);\n            return [getCol, _this5.get(getCol).iloc(rowIdx, rowIdx + 1)];\n          }).toArray()), {\n            index: this.index.slice(rowIdx, rowIdx + 1)\n          });\n        } else if (typeof colIdx === 'undefined') {\n          return new DataFrame(_immutable2.default.Map(this.columns.map(function (c) {\n            return [c, _this5.get(c).iloc(rowIdx, rowIdx + 1)];\n          }).toArray()), {\n            index: this.index.slice(rowIdx, rowIdx + 1)\n          });\n        }\n        throw new TypeError('colIdx must be either integer or Array of integers');\n      } else if (Array.isArray(rowIdx)) {\n        if (typeof colIdx === 'number') {\n          if (colIdx < 0 || colIdx >= this.shape[1]) throw new Error('colIdx out of bounds');\n          var _getCol = this.columns.get(colIdx);\n          return new DataFrame(_immutable2.default.Map([[_getCol, this.get(_getCol).iloc(rowIdx[0], rowIdx[1])]]), {\n            index: this.index.slice(rowIdx[0], rowIdx[1])\n          });\n        } else if (Array.isArray(colIdx)) {\n          if (colIdx.length !== 2) throw new Error('colIdx must be length 2 (start and end positions)');\n          if (colIdx[1] <= colIdx[0]) throw new Error('colIdx end position cannot be less than or equal tostart position');\n          if (colIdx[0] < 0 || colIdx[1] > this.shape[1]) throw new Error('colIdx position out of bounds');\n          return new DataFrame(_immutable2.default.Map(_immutable2.default.Range(colIdx[0], colIdx[1]).map(function (idx) {\n            var getCol = _this5.columns.get(idx);\n            return [getCol, _this5.get(getCol).iloc(rowIdx[0], rowIdx[1])];\n          }).toArray()), {\n            index: this.index.slice(rowIdx[0], rowIdx[1])\n          });\n        } else if (typeof colIdx === 'undefined') {\n          return new DataFrame(_immutable2.default.Map(this.columns.map(function (c) {\n            return [c, _this5.get(c).iloc(rowIdx[0], rowIdx[1])];\n          }).toArray()), {\n            index: this.index.slice(rowIdx[0], rowIdx[1])\n          });\n        }\n        throw new TypeError('colIdx must be either integer or Array of integers');\n      }\n      throw new TypeError('rowIdx must be either integer or Array of integers');\n    }\n  }, {\n    key: 'head',\n    value: function head() {\n      var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;\n      return this.iloc([0, n]);\n    }\n  }, {\n    key: 'tail',\n    value: function tail() {\n      var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;\n      return this.iloc([this.length - n, this.length]);\n    }\n  }, {\n    key: '_assertColumnExists',\n    value: function _assertColumnExists(col) {\n      if (!this.columnExists(col)) throw new Error('Column ' + col + ' not in DataFrame');\n    }\n  }, {\n    key: 'columnExists',\n    value: function columnExists(col) {\n      return this.columns.indexOf(col) >= 0;\n    }\n  }, {\n    key: 'get',\n    value: function get(columns) {\n      var _this6 = this;\n      if ((typeof columns === 'string' || typeof columns === 'number') && this.columnExists(columns)) return this._data.get(columns);else if (Array.isArray(columns) || columns instanceof _immutable2.default.List || columns instanceof _immutable2.default.Seq) {\n        columns.forEach(function (c) {\n          if (!_this6.columnExists(c)) throw new Error('KeyError: ' + c + ' not found');\n        });\n        return new DataFrame(_immutable2.default.Map(columns.map(function (c) {\n          return [c, _this6.get(c)];\n        })), this.kwargs);\n      }\n      throw new Error('KeyError: ' + columns + ' not found');\n    }\n  }, {\n    key: 'where',\n    value: function where(other, op) {\n      if (!Array.isArray(other) && !(other instanceof _immutable2.default.List) && !(other instanceof _series2.default) && !(other instanceof DataFrame)) {\n        return new DataFrame(_immutable2.default.Map(this._data.mapEntries(function (_ref) {\n          var _ref2 = (0, _slicedToArray3.default)(_ref, 2),\n            k = _ref2[0],\n            v = _ref2[1];\n          return [k, v.where(other, op)];\n        })));\n      } else if (Array.isArray(other) || other instanceof _series2.default || other instanceof _immutable2.default.List) {\n        if ((Array.isArray(other) || other instanceof _series2.default) && other.length !== this.length) throw new Error('Array or Series must be same length as DataFrame');\n        if (other instanceof _immutable2.default.List && other.size !== this.length) throw new Error('Immutable List must be same size as DataFrame');\n        return new DataFrame(_immutable2.default.Map(this._data.mapEntries(function (_ref3) {\n          var _ref4 = (0, _slicedToArray3.default)(_ref3, 2),\n            k = _ref4[0],\n            v = _ref4[1];\n          return [k, v.where(other, op)];\n        })));\n      } else if (other instanceof DataFrame) {\n        if (!other.shape.equals(this.shape)) throw new Error('DataFrame must have the same shape');\n        return new DataFrame(_immutable2.default.Map(this._data.mapEntries(function (_ref5, idx) {\n          var _ref6 = (0, _slicedToArray3.default)(_ref5, 2),\n            k = _ref6[0],\n            v = _ref6[1];\n          return [k, v.where(other.get(other.columns.get(idx)), op)];\n        })));\n      }\n      throw new Error('Unsupported comparison value, or non-matching lengths');\n    }\n  }, {\n    key: 'eq',\n    value: function eq(other) {\n      return this.where(other, function (a, b) {\n        return a === b;\n      });\n    }\n  }, {\n    key: 'gt',\n    value: function gt(other) {\n      return this.where(other, function (a, b) {\n        return a > b;\n      });\n    }\n  }, {\n    key: 'gte',\n    value: function gte(other) {\n      return this.where(other, function (a, b) {\n        return a >= b;\n      });\n    }\n  }, {\n    key: 'lt',\n    value: function lt(other) {\n      return this.where(other, function (a, b) {\n        return a < b;\n      });\n    }\n  }, {\n    key: 'lte',\n    value: function lte(other) {\n      return this.where(other, function (a, b) {\n        return a <= b;\n      });\n    }\n  }, {\n    key: 'merge',\n    value: function merge(df, on) {\n      var how = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'inner';\n      return mergeDataFrame(this, df, on, how);\n    }\n  }, {\n    key: 'to_csv',\n    value: function to_csv() {\n      var _this7 = this;\n      var csvString = '';\n      this.columns.forEach(function (k) {\n        csvString += k + ',';\n      });\n      csvString += '\\r\\n';\n      var updateString = function updateString(idx) {\n        var s = '';\n        _this7.columns.forEach(function (k) {\n          s += _this7.get(k).iloc(idx) + ',';\n        });\n        return s;\n      };\n      for (var idx = 0; idx < this.length; idx += 1) {\n        csvString += updateString(idx);\n        csvString += '\\r\\n';\n      }\n      return csvString;\n    }\n  }, {\n    key: 'to_excel',\n    value: function to_excel(excel_writer) {\n      var sheetName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'Sheet1';\n      var download = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var kwargs = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {\n        index: true\n      };\n      throw new Error('to_excel not yet implemented');\n    }\n  }, {\n    key: 'to_json',\n    value: function to_json() {\n      var _this8 = this;\n      var kwargs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n        orient: 'columns'\n      };\n      var ALLOWED_ORIENT = ['records', 'split', 'index', 'values', 'columns'];\n      var orient = 'columns';\n      if (typeof kwargs.orient !== 'undefined') {\n        if (ALLOWED_ORIENT.indexOf(kwargs.orient) < 0) throw new TypeError('orient must be in ' + ALLOWED_ORIENT.toString());\n        orient = kwargs.orient;\n      }\n      var json = void 0;\n      switch (orient) {\n        case 'records':\n          return this.values.map(function (row) {\n            var rowObj = {};\n            row.forEach(function (val, idx) {\n              rowObj[_this8.columns.get(idx)] = val;\n            });\n            return rowObj;\n          }).toArray();\n        case 'split':\n          return {\n            index: this.index.toArray(),\n            columns: this.columns.toArray(),\n            values: this.values.toJS()\n          };\n        case 'index':\n          json = {};\n          this.values.forEach(function (row, idx) {\n            var rowObj = {};\n            row.forEach(function (val, idx2) {\n              rowObj[_this8.columns.get(idx2)] = val;\n            });\n            json[_this8.index.get(idx)] = rowObj;\n          });\n          return json;\n        case 'values':\n          return this.values.toJS();\n        case 'columns':\n          json = {};\n          this.columns.forEach(function (c) {\n            json[c] = _this8.get(c).to_json({\n              orient: 'index'\n            });\n          });\n          return json;\n        default:\n          throw new TypeError('orient must be in ' + ALLOWED_ORIENT.toString());\n      }\n    }\n  }, {\n    key: 'sum',\n    value: function sum() {\n      var _this9 = this;\n      var axis = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      if (axis === 0) {\n        return new _series2.default(this.columns.toArray().map(function (k) {\n          return _this9.get(k).sum();\n        }), {\n          index: this.columns.toArray()\n        });\n      } else if (axis === 1) {\n        return new _series2.default(_immutable2.default.Range(0, this.length).map(function (idx) {\n          return _this9.values.get(idx).reduce(function (s, k) {\n            return s + k;\n          }, 0);\n        }).toList(), {\n          index: this.index\n        });\n      }\n      throw new _exceptions.InvalidAxisError();\n    }\n  }, {\n    key: 'mean',\n    value: function mean() {\n      var _this10 = this;\n      var axis = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      if (axis === 0) {\n        return new _series2.default(this.columns.toArray().map(function (k) {\n          return _this10.get(k).mean();\n        }), {\n          index: this.columns.toArray()\n        });\n      } else if (axis === 1) {\n        return new _series2.default(_immutable2.default.Range(0, this.length).map(function (idx) {\n          return _this10.values.get(idx).reduce(function (s, k) {\n            return s + k / _this10.columns.size;\n          }, 0);\n        }).toList(), {\n          index: this.index\n        });\n      }\n      throw new _exceptions.InvalidAxisError();\n    }\n  }, {\n    key: 'std',\n    value: function std() {\n      var _this11 = this;\n      var axis = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      if (axis === 0) {\n        return new _series2.default(this.columns.toArray().map(function (k) {\n          return _this11.get(k).std();\n        }), {\n          index: this.columns.toArray()\n        });\n      } else if (axis === 1) {\n        return this.variance(axis).map(function (v) {\n          return Math.sqrt(v);\n        });\n      }\n      throw new _exceptions.InvalidAxisError();\n    }\n  }, {\n    key: 'variance',\n    value: function variance() {\n      var _this12 = this;\n      var axis = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      if (axis === 0) {\n        return new _series2.default(this.columns.toArray().map(function (k) {\n          return _this12.get(k).variance();\n        }), {\n          index: this.columns.toArray()\n        });\n      } else if (axis === 1) {\n        var means = this.mean(axis).values;\n        return new _series2.default(_immutable2.default.Range(0, this.length).map(function (idx) {\n          return _this12.values.get(idx).reduce(function (s, k) {\n            var diff = k - means.get(idx);\n            return s + diff * diff / (_this12.columns.size - 1);\n          }, 0);\n        }).toArray(), {\n          index: this.index\n        });\n      }\n      throw new _exceptions.InvalidAxisError();\n    }\n  }, {\n    key: '_pairwiseDataFrame',\n    value: function _pairwiseDataFrame(func) {\n      var valArray = [];\n      for (var idx1 = 0; idx1 < this.columns.size; idx1 += 1) {\n        valArray.push({});\n        var ds1 = this.get(this.columns.get(idx1));\n        for (var idx2 = idx1; idx2 < this.columns.size; idx2 += 1) {\n          var col2 = this.columns.get(idx2);\n          var ds2 = this.get(col2);\n          valArray[idx1][col2] = func(ds1, ds2);\n        }\n      }\n      for (var _idx = 0; _idx < this.columns.size; _idx += 1) {\n        var col1 = this.columns.get(_idx);\n        for (var _idx2 = _idx + 1; _idx2 < this.columns.size; _idx2 += 1) {\n          var _col = this.columns.get(_idx2);\n          valArray[_idx2][col1] = valArray[_idx][_col];\n        }\n      }\n      return new DataFrame(valArray, {\n        index: this.columns.toList()\n      });\n    }\n  }, {\n    key: 'cov',\n    value: function cov() {\n      return this._pairwiseDataFrame(function (ds1, ds2) {\n        return ds1.cov(ds2);\n      });\n    }\n  }, {\n    key: 'corr',\n    value: function corr() {\n      var corrFunc = function corrFunc(ds1, ds2) {\n        return ds1.values === ds2.values ? 1 : ds1.corr(ds2);\n      };\n      return this._pairwiseDataFrame(corrFunc);\n    }\n  }, {\n    key: 'diff',\n    value: function diff() {\n      var _this13 = this;\n      var periods = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n      var axis = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      if (typeof periods !== 'number' || !Number.isInteger(periods)) throw new Error('periods must be an integer');\n      if (periods <= 0) throw new Error('periods must be positive');\n      if (axis === 0) {\n        return new DataFrame(_immutable2.default.Map(this.columns.map(function (k) {\n          return [k, _this13._data.get(k).diff(periods)];\n        })), {\n          index: this.index\n        });\n      } else if (axis === 1) {\n        return new DataFrame(_immutable2.default.Map(this.columns.map(function (k, idx) {\n          if (idx < periods) return [k, new _series2.default(_immutable2.default.Repeat(null, _this13.length).toList(), {\n            name: k,\n            index: _this13.index\n          })];\n          var compareCol = _this13.get(_this13.columns.get(idx - periods));\n          return [k, _this13.get(k).map(function (v, vIdx) {\n            return v - compareCol.iloc(vIdx);\n          })];\n        })), {\n          index: this.index\n        });\n      }\n      throw new _exceptions.InvalidAxisError();\n    }\n  }, {\n    key: 'pct_change',\n    value: function pct_change() {\n      var _this14 = this;\n      var periods = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n      var axis = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      if (typeof periods !== 'number' || !Number.isInteger(periods)) throw new Error('periods must be an integer');\n      if (periods <= 0) throw new Error('periods must be positive');\n      if (axis === 0) {\n        return new DataFrame(_immutable2.default.Map(this.columns.map(function (k) {\n          return [k, _this14._data.get(k).pct_change(periods)];\n        })), {\n          index: this.index\n        });\n      } else if (axis === 1) {\n        return new DataFrame(_immutable2.default.Map(this.columns.map(function (k, idx) {\n          if (idx < periods) return [k, new _series2.default(_immutable2.default.Repeat(null, _this14.length).toList(), {\n            name: k,\n            index: _this14.index\n          })];\n          var compareCol = _this14.get(_this14.columns.get(idx - periods));\n          return [k, _this14.get(k).map(function (v, vIdx) {\n            return v / compareCol.iloc(vIdx) - 1;\n          })];\n        })), {\n          index: this.index\n        });\n      }\n      throw new _exceptions.InvalidAxisError();\n    }\n  }, {\n    key: 'filter',\n    value: function filter(iterBool) {\n      if (!Array.isArray(iterBool) && !(iterBool instanceof _immutable2.default.List) && !(iterBool instanceof _series2.default)) throw new Error('filter must be an Array, List, or Series');\n      if (Array.isArray(iterBool) && iterBool.length !== this.length) throw new Error('Array must be of equal length to DataFrame');else if (iterBool instanceof _immutable2.default.List && iterBool.size !== this.length) throw new Error('List must be of equal length to DataFrame');else if (iterBool instanceof _series2.default && iterBool.length !== this.length) throw new Error('Series must be of equal length to DataFrame');\n      return new DataFrame(_immutable2.default.Map(this._data.mapEntries(function (_ref7) {\n        var _ref8 = (0, _slicedToArray3.default)(_ref7, 2),\n          k = _ref8[0],\n          v = _ref8[1];\n        return [k, v.filter(iterBool)];\n      })));\n    }\n  }, {\n    key: 'pivot',\n    value: function pivot(index, columns, values) {\n      var _this15 = this;\n      var uniqueVals = _immutable2.default.Map({});\n      var uniqueCols = _immutable2.default.List([]);\n      this.index.forEach(function (v, idx) {\n        var idxVal = _this15.get(index).iloc(idx);\n        var colVal = _this15.get(columns).iloc(idx);\n        if (uniqueVals.hasIn([idxVal, colVal])) throw new Error('pivot index and column must be unique');\n        var val = _this15.get(values).iloc(idx);\n        uniqueVals = uniqueVals.setIn([idxVal, colVal], val);\n        if (!uniqueCols.has(colVal)) uniqueCols = uniqueCols.push(colVal);\n      });\n      var sortedIndex = uniqueVals.keySeq().sort().toArray();\n      var sortedColumns = uniqueCols.sort();\n      var data = _immutable2.default.OrderedMap(sortedColumns.map(function (col) {\n        return [col, new _series2.default(sortedIndex.map(function (idx) {\n          var val = uniqueVals.getIn([idx, col]);\n          return typeof val === 'undefined' ? null : val;\n        }), {\n          name: col,\n          index: sortedIndex\n        })];\n      }));\n      return new DataFrame(data, {\n        index: sortedIndex\n      });\n    }\n  }, {\n    key: 'pivot_table',\n    value: function pivot_table(index, columns, values) {\n      var aggfunc = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'sum';\n      throw new Error('Not implemented');\n    }\n  }, {\n    key: '_cumulativeHelper',\n    value: function _cumulativeHelper() {\n      var _this16 = this;\n      var operation = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _utils.OP_CUMSUM;\n      var axis = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      if (axis === 0) {\n        return new DataFrame(_immutable2.default.Map(this.columns.map(function (c) {\n          return [c, _this16.get(c)._cumulativeHelper(operation)];\n        })), this.kwargs);\n      } else if (axis === 1) {\n        return new DataFrame(this.values.map(function (row) {\n          return (0, _utils.generateCumulativeFunc)(operation)(row);\n        }), this.kwargs);\n      }\n      throw new Error('invalid axis');\n    }\n  }, {\n    key: 'cumsum',\n    value: function cumsum() {\n      var axis = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      return this._cumulativeHelper(_utils.OP_CUMSUM, axis);\n    }\n  }, {\n    key: 'cummul',\n    value: function cummul() {\n      var axis = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      return this._cumulativeHelper(_utils.OP_CUMMUL, axis);\n    }\n  }, {\n    key: 'cummax',\n    value: function cummax() {\n      var axis = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      return this._cumulativeHelper(_utils.OP_CUMMAX, axis);\n    }\n  }, {\n    key: 'cummin',\n    value: function cummin() {\n      var axis = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      return this._cumulativeHelper(_utils.OP_CUMMIN, axis);\n    }\n  }, {\n    key: 'rename',\n    value: function rename(_ref9) {\n      var _this17 = this;\n      var columns = _ref9.columns;\n      return new DataFrame(_immutable2.default.OrderedMap(this.columns.map(function (prevCol) {\n        var nextCol = columns.get(prevCol);\n        if (typeof nextCol === 'undefined') return [prevCol, _this17._data.get(prevCol)];\n        return [nextCol, _this17._data.get(prevCol).rename(nextCol)];\n      })), {\n        index: this.index\n      });\n    }\n  }, {\n    key: 'append',\n    value: function append(other) {\n      var ignore_index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      return _concatDataFrame([this, other], {\n        ignore_index: ignore_index\n      });\n    }\n  }, {\n    key: 'transpose',\n    value: function transpose() {\n      var _this18 = this;\n      return new DataFrame(_immutable2.default.OrderedMap(this.index.map(function (index, idx) {\n        return [index, new _series2.default(_this18.values.get(idx), {\n          index: _this18.columns.toList()\n        })];\n      })));\n    }\n  }, {\n    key: 'kwargs',\n    get: function get() {\n      return {\n        index: this.index,\n        columns: this.columns\n      };\n    }\n  }, {\n    key: 'values',\n    get: function get() {\n      var _this19 = this;\n      if (this._values instanceof _immutable2.default.List) return (0, _get3.default)(DataFrame.prototype.__proto__ || Object.getPrototypeOf(DataFrame.prototype), 'values', this);\n      var valuesList = _immutable2.default.List([]);\n      var _loop = function _loop(idx) {\n        valuesList = valuesList.concat([_immutable2.default.List(_this19.columns.map(function (k) {\n          return _this19._data.get(k).iloc(idx);\n        }))]);\n      };\n      for (var idx = 0; idx < this.length; idx += 1) {\n        _loop(idx);\n      }\n      this._values = valuesList;\n      return (0, _get3.default)(DataFrame.prototype.__proto__ || Object.getPrototypeOf(DataFrame.prototype), 'values', this);\n    }\n  }, {\n    key: 'columns',\n    get: function get() {\n      return this._get_axis(1);\n    },\n    set: function set(columns) {\n      var _this20 = this;\n      if (!Array.isArray(columns) || columns.length !== this.columns.size) throw new Error('Columns must be array of same dimension');\n      var nextData = {};\n      columns.forEach(function (k, idx) {\n        var prevColumn = _this20.columns.get(idx);\n        var prevSeries = _this20.get(prevColumn);\n        nextData[k] = prevSeries.rename(k);\n      });\n      this._data = _immutable2.default.Map(nextData);\n      this.set_axis(1, _immutable2.default.Seq(columns));\n    }\n  }, {\n    key: 'index',\n    get: function get() {\n      return this._get_axis(0);\n    },\n    set: function set(index) {\n      var _this21 = this;\n      this.set_axis(0, (0, _utils.parseIndex)(index, this._data.get(this.columns.get(0)).values));\n      this._data.mapEntries(function (_ref10) {\n        var _ref11 = (0, _slicedToArray3.default)(_ref10, 2),\n          k = _ref11[0],\n          v = _ref11[1];\n        v.index = _this21.index;\n      });\n    }\n  }, {\n    key: 'length',\n    get: function get() {\n      var _this22 = this;\n      return Math.max.apply(Math, [0].concat((0, _toConsumableArray3.default)(this.columns.map(function (k) {\n        return _this22.get(k).length;\n      }).toArray())));\n    }\n  }]);\n  return DataFrame;\n}(_generic2.default);\nexports.default = DataFrame;\nvar innerMerge = function innerMerge(df1, df2, on) {\n  var data = [];\n  var cols1 = (0, _utils.nonMergeColumns)(df1.columns, on);\n  var cols2 = (0, _utils.nonMergeColumns)(df2.columns, on);\n  var intersectCols = (0, _utils.intersectingColumns)(cols1, cols2);\n  intersectCols.count();\n  var cols1Rename = cols1.map(function (k) {\n    return intersectCols.size > 0 && intersectCols.indexOf(k) >= 0 ? k + '_x' : k;\n  });\n  var cols2Rename = cols2.map(function (k) {\n    return intersectCols.size > 0 && intersectCols.indexOf(k) >= 0 ? k + '_y' : k;\n  });\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n  try {\n    var _loop2 = function _loop2() {\n      var _step$value = (0, _slicedToArray3.default)(_step.value, 2),\n        row1 = _step$value[0],\n        _1 = _step$value[1];\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n      try {\n        var _loop3 = function _loop3() {\n          var _step2$value = (0, _slicedToArray3.default)(_step2.value, 2),\n            row2 = _step2$value[0],\n            _2 = _step2$value[1];\n          var match = true;\n          var _iteratorNormalCompletion3 = true;\n          var _didIteratorError3 = false;\n          var _iteratorError3 = undefined;\n          try {\n            for (var _iterator3 = on[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n              var c = _step3.value;\n              if (row1.get(c) !== row2.get(c)) {\n                match = false;\n                break;\n              }\n            }\n          } catch (err) {\n            _didIteratorError3 = true;\n            _iteratorError3 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion3 && _iterator3.return) {\n                _iterator3.return();\n              }\n            } finally {\n              if (_didIteratorError3) {\n                throw _iteratorError3;\n              }\n            }\n          }\n          if (match) {\n            var rowData = {};\n            on.forEach(function (k) {\n              rowData[k] = row1.get(k);\n            });\n            cols1.forEach(function (k, idx) {\n              rowData[cols1Rename.get(idx)] = row1.get(k);\n            });\n            cols2.forEach(function (k, idx) {\n              rowData[cols2Rename.get(idx)] = row2.get(k);\n            });\n            data.push(rowData);\n          }\n        };\n        for (var _iterator2 = df2.iterrows()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          _loop3();\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n    };\n    for (var _iterator = df1.iterrows()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      _loop2();\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n  return new DataFrame(data);\n};\nvar outerMerge = function outerMerge(df1, df2, on) {\n  var data = [];\n  var cols1 = (0, _utils.nonMergeColumns)(df1.columns, on);\n  var cols2 = (0, _utils.nonMergeColumns)(df2.columns, on);\n  var intersectCols = (0, _utils.intersectingColumns)(cols1, cols2);\n  intersectCols.count();\n  var matched1 = new Array(df1.length).fill(false);\n  var matched2 = new Array(df2.length).fill(false);\n  var _iteratorNormalCompletion4 = true;\n  var _didIteratorError4 = false;\n  var _iteratorError4 = undefined;\n  try {\n    var _loop4 = function _loop4() {\n      var _step4$value = (0, _slicedToArray3.default)(_step4.value, 2),\n        row1 = _step4$value[0],\n        idx_1 = _step4$value[1];\n      var _iteratorNormalCompletion5 = true;\n      var _didIteratorError5 = false;\n      var _iteratorError5 = undefined;\n      try {\n        var _loop5 = function _loop5() {\n          var _step5$value = (0, _slicedToArray3.default)(_step5.value, 2),\n            row2 = _step5$value[0],\n            idx_2 = _step5$value[1];\n          var match = true;\n          var _iteratorNormalCompletion6 = true;\n          var _didIteratorError6 = false;\n          var _iteratorError6 = undefined;\n          try {\n            for (var _iterator6 = on[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n              var c = _step6.value;\n              if (row1.get(c) !== row2.get(c)) {\n                match = false;\n                break;\n              }\n            }\n          } catch (err) {\n            _didIteratorError6 = true;\n            _iteratorError6 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion6 && _iterator6.return) {\n                _iterator6.return();\n              }\n            } finally {\n              if (_didIteratorError6) {\n                throw _iteratorError6;\n              }\n            }\n          }\n          var rowData = {};\n          on.forEach(function (k) {\n            rowData[k] = row1.get(k);\n          });\n          cols1.forEach(function (k) {\n            var nextColName = intersectCols.size > 0 && intersectCols.indexOf(k) >= 0 ? k + '_x' : k;\n            rowData[nextColName] = row1.get(k);\n          });\n          if (match) {\n            cols2.forEach(function (k) {\n              var nextColName = intersectCols.size > 0 && intersectCols.indexOf(k) >= 0 ? k + '_y' : k;\n              rowData[nextColName] = row2.get(k);\n            });\n            data.push(rowData);\n            matched1[idx_1] = true;\n            matched2[idx_2] = true;\n          }\n        };\n        for (var _iterator5 = df2.iterrows()[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n          _loop5();\n        }\n      } catch (err) {\n        _didIteratorError5 = true;\n        _iteratorError5 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion5 && _iterator5.return) {\n            _iterator5.return();\n          }\n        } finally {\n          if (_didIteratorError5) {\n            throw _iteratorError5;\n          }\n        }\n      }\n    };\n    for (var _iterator4 = df1.iterrows()[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n      _loop4();\n    }\n  } catch (err) {\n    _didIteratorError4 = true;\n    _iteratorError4 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion4 && _iterator4.return) {\n        _iterator4.return();\n      }\n    } finally {\n      if (_didIteratorError4) {\n        throw _iteratorError4;\n      }\n    }\n  }\n  matched1.forEach(function (m, idx) {\n    if (!m) {\n      var rowData = {};\n      on.forEach(function (k) {\n        rowData[k] = df1.get(k).iloc(idx);\n      });\n      cols1.forEach(function (k) {\n        var nextColName = intersectCols.size > 0 && intersectCols.indexOf(k) >= 0 ? k + '_x' : k;\n        rowData[nextColName] = df1.get(k).iloc(idx);\n      });\n      cols2.forEach(function (k) {\n        var nextColName = intersectCols.size > 0 && intersectCols.indexOf(k) >= 0 ? k + '_y' : k;\n        rowData[nextColName] = null;\n      });\n      data.push(rowData);\n    }\n  });\n  matched2.forEach(function (m, idx) {\n    if (!m) {\n      var rowData = {};\n      on.forEach(function (k) {\n        rowData[k] = df2.get(k).iloc(idx);\n      });\n      cols1.forEach(function (k) {\n        var nextColName = intersectCols.size > 0 && intersectCols.indexOf(k) >= 0 ? k + '_x' : k;\n        rowData[nextColName] = null;\n      });\n      cols2.forEach(function (k) {\n        var nextColName = intersectCols.size > 0 && intersectCols.indexOf(k) >= 0 ? k + '_y' : k;\n        rowData[nextColName] = df2.get(k).iloc(idx);\n      });\n      data.push(rowData);\n    }\n  });\n  return new DataFrame(data);\n};\nvar mergeDataFrame = exports.mergeDataFrame = function mergeDataFrame(df1, df2, on) {\n  var how = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'inner';\n  var mergeOn = void 0;\n  if (typeof on === 'undefined') {\n    mergeOn = df1.columns.filter(function (c1) {\n      return df2.columns.filter(function (c2) {\n        return c1 === c2;\n      }).size > 0;\n    });\n    if (mergeOn.size === 0) throw new Error('No common keys');\n  } else {\n    on.forEach(function (col) {\n      if (!df1.columnExists(col) || !df2.columnExists(col)) throw new Error('KeyError: ' + col + ' not found');\n    });\n    mergeOn = on;\n  }\n  switch (how) {\n    case 'inner':\n      return innerMerge(df1, df2, mergeOn);\n    case 'outer':\n      return outerMerge(df1, df2, mergeOn);\n    default:\n      throw new Error('MergeError: ' + how + ' not a supported merge type');\n  }\n};\nvar _concatDataFrame = exports._concatDataFrame = function _concatDataFrame(objs, kwargs) {\n  if (!(objs instanceof _immutable2.default.List || Array.isArray(objs))) throw new Error('objs must be List or Array');\n  if (objs instanceof _immutable2.default.List && objs.filter(function (frame) {\n    return frame instanceof DataFrame;\n  }).size !== objs.size) throw new Error('Objects must all be DataFrame');else if (Array.isArray(objs) && objs.filter(function (frame) {\n    return frame instanceof DataFrame;\n  }).length !== objs.length) throw new Error('Objects must all be DataFrame');\n  if (Array.isArray(objs) && objs.length === 1) return objs[0];else if (objs instanceof _immutable2.default.List && objs.size === 1) return objs.get(0);\n  var seriesOrderedMap = _immutable2.default.OrderedMap({});\n  if (kwargs.axis === 1) {\n    objs.forEach(function (df) {\n      df.columns.forEach(function (column) {\n        var columnExists = seriesOrderedMap.has(column);\n        seriesOrderedMap = seriesOrderedMap.set(columnExists ? column + '.x' : column, columnExists ? df.get(column).rename(column + '.x') : df.get(column));\n      });\n    });\n  } else {\n    objs.forEach(function (df) {\n      var lenSeriesInMap = seriesOrderedMap.keySeq().size === 0 ? 0 : seriesOrderedMap.first().length;\n      var nextLength = df.length + lenSeriesInMap;\n      seriesOrderedMap = _immutable2.default.OrderedMap(seriesOrderedMap.entrySeq().map(function (_ref12) {\n        var _ref13 = (0, _slicedToArray3.default)(_ref12, 2),\n          column = _ref13[0],\n          series = _ref13[1];\n        if (df.columnExists(column)) return [column, (0, _series._concatSeries)([series, df.get(column)], kwargs)];\n        return [column, (0, _series._concatSeries)([series, new _series2.default(_immutable2.default.Repeat(NaN, df.length).toList(), {\n          index: df.index\n        })], kwargs)];\n      })).merge(_immutable2.default.OrderedMap(df.columns.filter(function (column) {\n        return !seriesOrderedMap.has(column);\n      }).map(function (column) {\n        return [column, lenSeriesInMap === 0 ? df.get(column) : (0, _series._concatSeries)([new _series2.default(_immutable2.default.Repeat(NaN, nextLength)), df.get(column)], kwargs)];\n      })));\n    });\n  }\n  return new DataFrame(seriesOrderedMap);\n};","map":null,"metadata":{},"sourceType":"script"}