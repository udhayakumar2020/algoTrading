{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports._concatSeries = undefined;\nvar _toConsumableArray2 = require('babel-runtime/helpers/toConsumableArray');\nvar _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\nvar _createClass2 = require('babel-runtime/helpers/createClass');\nvar _createClass3 = _interopRequireDefault(_createClass2);\nvar _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\nvar _get2 = require('babel-runtime/helpers/get');\nvar _get3 = _interopRequireDefault(_get2);\nvar _inherits2 = require('babel-runtime/helpers/inherits');\nvar _inherits3 = _interopRequireDefault(_inherits2);\nvar _immutable = require('immutable');\nvar _immutable2 = _interopRequireDefault(_immutable);\nvar _generic = require('./generic');\nvar _generic2 = _interopRequireDefault(_generic);\nvar _utils = require('./utils');\nvar _dtype = require('./dtype');\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nvar Series = function (_NDFrame) {\n  (0, _inherits3.default)(Series, _NDFrame);\n  function Series(data) {\n    var kwargs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    (0, _classCallCheck3.default)(this, Series);\n    var _this = (0, _possibleConstructorReturn3.default)(this, (Series.__proto__ || Object.getPrototypeOf(Series)).call(this, data, kwargs));\n    if (Array.isArray(data)) {\n      _this._values = _immutable2.default.List(data);\n      _this._dtype = (0, _dtype.arrayToDType)(data);\n    } else if (data instanceof _immutable2.default.List) {\n      _this._values = data;\n      _this._dtype = (0, _dtype.arrayToDType)(data);\n    } else {\n      _this._values = _immutable2.default.List.of(data);\n      _this._dtype = (0, _dtype.arrayToDType)([data]);\n    }\n    _this._name = typeof kwargs.name !== 'undefined' ? kwargs.name : '';\n    _this.set_axis(0, (0, _utils.parseIndex)(kwargs.index, _this.values));\n    _this._setup_axes(_immutable2.default.List.of(0));\n    _this._sort_ascending = _this._sort_ascending.bind(_this);\n    _this._sort_descending = _this._sort_descending.bind(_this);\n    return _this;\n  }\n  (0, _createClass3.default)(Series, [{\n    key: Symbol.iterator,\n    value: function value() {\n      var values = this.values;\n      var index = -1;\n      return {\n        next: function next() {\n          index += 1;\n          return {\n            value: values.get(index),\n            done: !(index >= 0 && index < values.size)\n          };\n        }\n      };\n    }\n  }, {\n    key: 'map',\n    value: function map(func) {\n      return new Series(this.values.map(function (val, idx) {\n        return func(val, idx);\n      }), {\n        name: this.name,\n        index: this.index\n      });\n    }\n  }, {\n    key: 'forEach',\n    value: function forEach(func) {\n      this.values.forEach(function (val, idx) {\n        return func(val, idx);\n      });\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      var _this2 = this;\n      var vals = this.iloc(0, 10).values;\n      var valString = '';\n      vals.forEach(function (v, idx) {\n        valString += _this2.index.get(idx) + '\\t' + v + '\\n';\n      });\n      return valString + 'Name: ' + this.name + ', dtype: ' + this.dtype;\n    }\n  }, {\n    key: 'head',\n    value: function head() {\n      var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 5;\n      return this.iloc(0, n);\n    }\n  }, {\n    key: 'tail',\n    value: function tail() {\n      var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 5;\n      return this.iloc(this.length - n, this.length);\n    }\n  }, {\n    key: 'copy',\n    value: function copy() {\n      return new Series(this.values, {\n        index: this.index,\n        name: this.name\n      });\n    }\n  }, {\n    key: 'astype',\n    value: function astype(nextType) {\n      if (!(nextType instanceof _dtype.DType)) throw new Error('Next type must be a DType');\n      if (nextType.dtype === this.dtype) return this;\n      switch (nextType.dtype) {\n        case 'int':\n          {\n            if (this.dtype.dtype === 'object') throw new Error('Cannot convert object to int');\n            var kwargs = {\n              name: this.name,\n              index: this.index\n            };\n            return new Series(this.values.map(function (v) {\n              return Math.floor(v);\n            }), kwargs);\n          }\n        case 'float':\n          {\n            if (this.dtype.dtype === 'object') throw new Error('Cannot convert object to float');\n            var _kwargs = {\n              name: this.name,\n              index: this.index\n            };\n            return new Series(this.values.map(function (v) {\n              return parseFloat(v);\n            }), _kwargs);\n          }\n        default:\n          throw new Error('Invalid dtype ' + nextType);\n      }\n    }\n  }, {\n    key: 'iloc',\n    value: function iloc(startVal, endVal) {\n      if (typeof endVal === 'undefined') return this.values.get(startVal);\n      var name = this.kwargs.name;\n      var index = this.index.slice(startVal, endVal);\n      return new Series(this.values.slice(startVal, endVal), {\n        name: name,\n        index: index\n      });\n    }\n  }, {\n    key: 'sum',\n    value: function sum() {\n      return (0, _utils.sum)(this.values);\n    }\n  }, {\n    key: 'mean',\n    value: function mean() {\n      return this.sum() / this.length;\n    }\n  }, {\n    key: 'median',\n    value: function median() {\n      var sortedVals = this.values.sort();\n      if (this.length % 2 === 1) return sortedVals.get(Math.floor(this.length / 2));\n      var halfLength = this.length / 2;\n      return (sortedVals.get(halfLength - 1) + sortedVals.get(halfLength)) / 2;\n    }\n  }, {\n    key: 'variance',\n    value: function variance() {\n      var _this3 = this;\n      var mean = this.mean();\n      return this.values.reduce(function (s, v) {\n        var diff = v - mean;\n        return s + diff * diff / (_this3.length - 1);\n      }, 0);\n    }\n  }, {\n    key: 'std',\n    value: function std() {\n      return Math.sqrt(this.variance());\n    }\n  }, {\n    key: 'abs',\n    value: function abs() {\n      if (['bool', 'string', 'object'].indexOf(this.dtype.dtype) >= 0) return this.copy();\n      return new Series(this.values.map(function (v) {\n        return Math.abs(v);\n      }), {\n        name: this.name,\n        index: this.index\n      });\n    }\n  }, {\n    key: '_combineOp',\n    value: function _combineOp(other, op) {\n      var opName = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n      if (typeof other === 'number') return this.map(function (val) {\n        return op(val, other);\n      });else if (other instanceof Series) return this.map(function (val, idx) {\n        return op(val, other.iloc(idx));\n      });else if (Array.isArray(other)) return this.map(function (val, idx) {\n        return op(val, other[idx]);\n      });else if (other instanceof _immutable2.default.List) return this.map(function (val, idx) {\n        return op(val, other.get(idx));\n      });\n      throw new Error(opName + ' only supports numbers, Arrays, Immutable List and pandas.Series');\n    }\n  }, {\n    key: 'add',\n    value: function add(other) {\n      return this._combineOp(other, function (a, b) {\n        return a + b;\n      }, 'add');\n    }\n  }, {\n    key: 'sub',\n    value: function sub(other) {\n      return this._combineOp(other, function (a, b) {\n        return a - b;\n      }, 'sub');\n    }\n  }, {\n    key: 'mul',\n    value: function mul(other) {\n      return this._combineOp(other, function (a, b) {\n        return a * b;\n      });\n    }\n  }, {\n    key: 'multiply',\n    value: function multiply(other) {\n      return this.mul(other);\n    }\n  }, {\n    key: 'div',\n    value: function div(other) {\n      return this._combineOp(other, function (a, b) {\n        return a / b;\n      }, 'div');\n    }\n  }, {\n    key: 'divide',\n    value: function divide(other) {\n      return this.div(other);\n    }\n  }, {\n    key: 'cov',\n    value: function cov(ds) {\n      if (!(ds instanceof Series)) throw new Error('ds must be a Series');\n      if (ds.length !== this.length) throw new Error('Series must be of equal length');\n      var n = 0;\n      var mean1 = 0;\n      var mean2 = 0;\n      var m12 = 0;\n      this.values.forEach(function (v1, idx) {\n        n += 1;\n        var d1 = (v1 - mean1) / n;\n        mean1 += d1;\n        var d2 = (ds.values.get(idx) - mean2) / n;\n        mean2 += d2;\n        m12 += (n - 1) * d1 * d2 - m12 / n;\n      });\n      return n / (n - 1) * m12;\n    }\n  }, {\n    key: 'corr',\n    value: function corr(ds) {\n      if (!(ds instanceof Series)) throw new Error('ds must be a Series');\n      if (ds.length !== this.length) throw new Error('Series must be of equal length');\n      return this.cov(ds) / (this.std() * ds.std());\n    }\n  }, {\n    key: 'diff',\n    value: function diff() {\n      var _this4 = this;\n      var periods = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n      if (typeof periods !== 'number' || !Number.isInteger(periods)) throw new Error('periods must be an integer');\n      if (periods <= 0) throw new Error('periods must be positive');\n      return new Series(_immutable2.default.Repeat(null, periods).toList().concat(_immutable2.default.Range(periods, this.length).map(function (idx) {\n        return _this4.values.get(idx) - _this4.values.get(idx - periods);\n      }).toList()), {\n        index: this.index,\n        name: this.name\n      });\n    }\n  }, {\n    key: 'pct_change',\n    value: function pct_change() {\n      var _this5 = this;\n      var periods = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n      if (typeof periods !== 'number' || !Number.isInteger(periods)) throw new Error('periods must be an integer');\n      if (periods <= 0) throw new Error('periods must be positive');\n      return new Series(_immutable2.default.Repeat(null, periods).toList().concat(_immutable2.default.Range(periods, this.length).map(function (idx) {\n        return _this5.values.get(idx) / _this5.values.get(idx - periods) - 1;\n      }).toList()), {\n        index: this.index,\n        name: this.name\n      });\n    }\n  }, {\n    key: '_sort_ascending',\n    value: function _sort_ascending(valueA, valueB) {\n      var valA = this.iloc(valueA);\n      var valB = this.iloc(valueB);\n      if (valA < valB) return -1;else if (valA > valB) return 1;\n      return 0;\n    }\n  }, {\n    key: '_sort_descending',\n    value: function _sort_descending(valueA, valueB) {\n      var valA = this.iloc(valueA);\n      var valB = this.iloc(valueB);\n      if (valA > valB) return -1;else if (valA < valB) return 1;\n      return 0;\n    }\n  }, {\n    key: 'sort_values',\n    value: function sort_values() {\n      var _this6 = this;\n      var ascending = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      var sortedIndex = ascending ? this.index.sort(this._sort_ascending) : this.index.sort(this._sort_descending);\n      return new Series(sortedIndex.map(function (i) {\n        return _this6.iloc(i);\n      }), {\n        name: this.name,\n        index: sortedIndex\n      });\n    }\n  }, {\n    key: 'round',\n    value: function round() {\n      var decimals = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      return new Series(this.values.map(function (v) {\n        return (0, _utils.round10)(v, -1 * decimals);\n      }));\n    }\n  }, {\n    key: '_alignSeries',\n    value: function _alignSeries(series) {\n      var _this7 = this;\n      var seriesAlignment = _immutable2.default.Map({});\n      this.index.forEach(function (idx1) {\n        if (!seriesAlignment.has(idx1)) {\n          seriesAlignment = seriesAlignment.set(idx1, _immutable2.default.Map({\n            first: _immutable2.default.List.of(_this7.iloc(idx1)),\n            second: _immutable2.default.List([])\n          }));\n        } else {\n          seriesAlignment = seriesAlignment.updateIn([idx1, 'first'], function (l) {\n            return l.concat(_this7.iloc(idx1));\n          });\n        }\n      });\n      series.index.forEach(function (idx2) {\n        if (!seriesAlignment.has(idx2)) {\n          seriesAlignment = seriesAlignment.set(idx2, _immutable2.default.Map({\n            first: _immutable2.default.List([]),\n            second: _immutable2.default.List.of(series.iloc(idx2))\n          }));\n        } else {\n          seriesAlignment = seriesAlignment.updateIn([idx2, 'second'], function (l) {\n            return l.concat(series.iloc(idx2));\n          });\n        }\n      });\n      return seriesAlignment;\n    }\n  }, {\n    key: 'where',\n    value: function where(other, op) {\n      var name = this.name;\n      var index = this.index;\n      var kwargs = {\n        name: name,\n        index: index\n      };\n      if (!Array.isArray(other) && !(other instanceof _immutable2.default.List) && !(other instanceof Series)) return new Series(this.values.map(function (v) {\n        return op(v, other);\n      }), kwargs);\n      if (Array.isArray(other)) {\n        if (other.length !== this.length) throw new Error('Must be equal length for comparison');\n        return new Series(this.values.map(function (v, idx) {\n          return op(v, other[idx]);\n        }), kwargs);\n      } else if (other instanceof _immutable2.default.List) {\n        if (other.size !== this.length) throw new Error('Must be equal length for comparison');\n        return new Series(this.values.map(function (v, idx) {\n          return op(v, other.get(idx));\n        }), kwargs);\n      } else if (other instanceof Series) {\n        if (other.length !== this.length) throw new Error('Must be equal length for comparison');\n        return new Series(this.values.map(function (v, idx) {\n          return op(v, other.iloc(idx));\n        }), kwargs);\n      }\n      throw new Error('Must be scalar value, Array, Series, or Immutable.List');\n    }\n  }, {\n    key: 'eq',\n    value: function eq(other) {\n      return this.where(other, function (a, b) {\n        return a === b;\n      });\n    }\n  }, {\n    key: 'lt',\n    value: function lt(other) {\n      return this.where(other, function (a, b) {\n        return a < b;\n      });\n    }\n  }, {\n    key: 'lte',\n    value: function lte(other) {\n      return this.where(other, function (a, b) {\n        return a <= b;\n      });\n    }\n  }, {\n    key: 'gt',\n    value: function gt(other) {\n      return this.where(other, function (a, b) {\n        return a > b;\n      });\n    }\n  }, {\n    key: 'gte',\n    value: function gte(other) {\n      return this.where(other, function (a, b) {\n        return a >= b;\n      });\n    }\n  }, {\n    key: 'notnull',\n    value: function notnull() {\n      return this.where(null, function (a, b) {\n        return a !== b;\n      });\n    }\n  }, {\n    key: 'shift',\n    value: function shift() {\n      var periods = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n      if (!Number.isInteger(periods)) throw new Error('periods must be an integer');\n      if (periods === 0) {\n        return this.copy();\n      } else if (periods < 0) {\n        var absPeriods = Math.abs(periods);\n        if (absPeriods > this.length) throw new Error('Periods greater than length of Series');\n        var _values = this.values.slice(absPeriods, this.length).concat(_immutable2.default.Repeat(null, absPeriods).toList());\n        return new Series(_values, {\n          name: this.name,\n          index: this.index\n        });\n      }\n      if (periods > this.length) throw new Error('Periods greater than length of Series');\n      var values = _immutable2.default.Repeat(null, periods).toList().concat(this.values.slice(0, this.length - periods));\n      return new Series(values, {\n        name: this.name,\n        index: this.index\n      });\n    }\n  }, {\n    key: 'unique',\n    value: function unique() {\n      return this.values.toSet().toList();\n    }\n  }, {\n    key: 'filter',\n    value: function filter(iterBool) {\n      var _this8 = this;\n      if (!Array.isArray(iterBool) && !(iterBool instanceof _immutable2.default.List) && !(iterBool instanceof Series)) throw new Error('filter must be an Array, List, or Series');\n      var valueIndexMap = {\n        values: [],\n        index: []\n      };\n      if (iterBool instanceof Series) iterBool.values.forEach(function (v, idx) {\n        if (v === true) {\n          valueIndexMap.values.push(_this8.values.get(idx));\n          valueIndexMap.index.push(_this8.index.get(idx));\n        }\n      });else {\n        iterBool.forEach(function (v, idx) {\n          if (v === true) {\n            valueIndexMap.values.push(_this8.values.get(idx));\n            valueIndexMap.index.push(_this8.index.get(idx));\n          }\n        });\n      }\n      return new Series(valueIndexMap.values, {\n        name: this.name,\n        index: valueIndexMap.index\n      });\n    }\n  }, {\n    key: '_cumulativeHelper',\n    value: function _cumulativeHelper() {\n      var operation = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _utils.OP_CUMSUM;\n      return new Series((0, _utils.generateCumulativeFunc)(operation)(this.values), this.kwargs);\n    }\n  }, {\n    key: 'cumsum',\n    value: function cumsum() {\n      return this._cumulativeHelper(_utils.OP_CUMSUM);\n    }\n  }, {\n    key: 'cummul',\n    value: function cummul() {\n      return this._cumulativeHelper(_utils.OP_CUMMUL);\n    }\n  }, {\n    key: 'cummax',\n    value: function cummax() {\n      return this._cumulativeHelper(_utils.OP_CUMMAX);\n    }\n  }, {\n    key: 'cummin',\n    value: function cummin() {\n      return this._cumulativeHelper(_utils.OP_CUMMIN);\n    }\n  }, {\n    key: 'to_json',\n    value: function to_json() {\n      var _this9 = this;\n      var kwargs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n        orient: 'index'\n      };\n      var ALLOWED_ORIENT = ['records', 'split', 'index'];\n      var orient = 'index';\n      if (typeof kwargs.orient !== 'undefined') {\n        if (ALLOWED_ORIENT.indexOf(kwargs.orient) < 0) throw new TypeError('orient must be in ' + ALLOWED_ORIENT);\n        orient = kwargs.orient;\n      }\n      var json = void 0;\n      switch (orient) {\n        case 'records':\n          return this.values.toArray();\n        case 'split':\n          return {\n            index: this.index.toArray(),\n            name: this.name,\n            values: this.values.toJS()\n          };\n        case 'index':\n          json = {};\n          this.values.forEach(function (v, idx) {\n            json[_this9.index.get(idx)] = v;\n          });\n          return json;\n        default:\n          throw new TypeError('orient must be in ' + ALLOWED_ORIENT);\n      }\n    }\n  }, {\n    key: 'rename',\n    value: function rename(name) {\n      return new Series(this._values, {\n        name: name,\n        index: this.index\n      });\n    }\n  }, {\n    key: 'append',\n    value: function append(other) {\n      var ignore_index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      return _concatSeries([this, other], {\n        ignore_index: ignore_index\n      });\n    }\n  }, {\n    key: 'kwargs',\n    get: function get() {\n      return {\n        name: this.name,\n        index: this.index\n      };\n    }\n  }, {\n    key: 'dtype',\n    get: function get() {\n      return this._dtype;\n    }\n  }, {\n    key: 'index',\n    get: function get() {\n      return this._get_axis(0);\n    },\n    set: function set(index) {\n      this.set_axis(0, (0, _utils.parseIndex)(index, this.values));\n    }\n  }, {\n    key: 'length',\n    get: function get() {\n      return this.values.size;\n    }\n  }, {\n    key: 'values',\n    get: function get() {\n      return (0, _get3.default)(Series.prototype.__proto__ || Object.getPrototypeOf(Series.prototype), 'values', this);\n    }\n  }, {\n    key: 'name',\n    get: function get() {\n      return this._name;\n    }\n  }]);\n  return Series;\n}(_generic2.default);\nexports.default = Series;\nvar _concatSeriesValues = function _concatSeriesValues(objs) {\n  var _Immutable$List;\n  return (_Immutable$List = _immutable2.default.List([])).concat.apply(_Immutable$List, (0, _toConsumableArray3.default)(objs.map(function (series) {\n    return series.values;\n  })));\n};\nvar _concatSeriesIndices = function _concatSeriesIndices(objs) {\n  var _Immutable$List2;\n  return (_Immutable$List2 = _immutable2.default.List([])).concat.apply(_Immutable$List2, (0, _toConsumableArray3.default)(objs.map(function (series) {\n    return series.index;\n  })));\n};\nvar _concatSeries = exports._concatSeries = function _concatSeries(objs, kwargs) {\n  if (objs instanceof _immutable2.default.List && objs.filter(function (series) {\n    return series instanceof Series;\n  }).size !== objs.size) throw new Error('Objects must all be Series');else if (Array.isArray(objs) && objs.filter(function (series) {\n    return series instanceof Series;\n  }).length !== objs.length) throw new Error('Objects must all be Series');\n  if (!kwargs.ignore_index) return new Series(_concatSeriesValues(objs), {\n    index: _concatSeriesIndices(objs)\n  });else if (kwargs.ignore_index) {\n    return new Series(_concatSeriesValues(objs), {\n      index: _immutable2.default.Range(0, objs.reduce(function (a, b) {\n        return a + b.length;\n      }, 0)).toList()\n    });\n  }\n  throw new Error('Not supported');\n};","map":null,"metadata":{},"sourceType":"script"}